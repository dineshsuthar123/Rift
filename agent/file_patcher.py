"""
File Patcher module.
Applies fixes generated by the LLM to actual source files in the repository.
"""
import os
import re
import sys
from typing import Dict, Any, List, Tuple


def apply_fix_to_file(repo_path: str, fix: Dict[str, Any]) -> bool:
    """
    Apply a single fix to a file in the repository.
    Returns True if the fix was applied successfully.
    """
    # Skip fixes already applied by ruff --fix
    if fix.get("_already_applied"):
        print(f"[PATCHER] Already applied by ruff: {fix.get('file_path', '')} line {fix.get('line_number', 0)}", file=sys.stderr)
        return True

    # Strip /workspace/ prefix that the Docker sandbox adds to file paths
    raw_path = fix["file_path"]
    cleaned = re.sub(r'^/?workspace/', '', raw_path)
    file_path = os.path.join(repo_path, cleaned)

    if not os.path.exists(file_path):
        print(f"[PATCHER] File not found: {file_path}", file=sys.stderr)
        return False

    try:
        with open(file_path, "r", encoding="utf-8", errors="replace") as f:
            lines = f.readlines()
    except Exception as e:
        print(f"[PATCHER] Error reading {file_path}: {e}", file=sys.stderr)
        return False

    line_number = fix.get("line_number", 0)
    original_code = fix.get("original_code", "")
    fixed_code = fix.get("fixed_code", "")

    if line_number < 1 or line_number > len(lines):
        print(f"[PATCHER] Line {line_number} out of range for {fix['file_path']} (has {len(lines)} lines)", file=sys.stderr)
        return False

    try:
        idx = line_number - 1  # Convert to 0-indexed

        # Strategy 1: Exact line replacement
        if original_code and original_code.strip() in lines[idx]:
            if fixed_code == "" or fixed_code is None:
                # Delete the line
                lines.pop(idx)
            else:
                # Replace preserving indentation
                current_indent = len(lines[idx]) - len(lines[idx].lstrip())
                indent = lines[idx][:current_indent]
                new_lines = fixed_code.strip().split("\n")
                replacement = "\n".join(indent + l for l in new_lines) + "\n"
                lines[idx] = replacement
        elif original_code:
            # Strategy 2: Search in a window around the line
            window = 5
            start = max(0, idx - window)
            end = min(len(lines), idx + window + 1)
            found = False
            for i in range(start, end):
                if original_code.strip() in lines[i]:
                    if fixed_code == "" or fixed_code is None:
                        lines.pop(i)
                    else:
                        current_indent = len(lines[i]) - len(lines[i].lstrip())
                        indent = lines[i][:current_indent]
                        new_lines = fixed_code.strip().split("\n")
                        replacement = "\n".join(indent + l for l in new_lines) + "\n"
                        lines[i] = replacement
                    found = True
                    break
            if not found:
                # Strategy 3: Direct line replacement
                if fixed_code == "" or fixed_code is None:
                    lines.pop(idx)
                else:
                    current_indent = len(lines[idx]) - len(lines[idx].lstrip())
                    indent = lines[idx][:current_indent]
                    new_lines = fixed_code.strip().split("\n")
                    replacement = "\n".join(indent + l for l in new_lines) + "\n"
                    lines[idx] = replacement
        else:
            # No original_code provided â€” just replace the line directly
            if fixed_code == "" or fixed_code is None:
                lines.pop(idx)
            else:
                current_indent = len(lines[idx]) - len(lines[idx].lstrip())
                indent = lines[idx][:current_indent]
                new_lines = fixed_code.strip().split("\n")
                replacement = "\n".join(indent + l for l in new_lines) + "\n"
                lines[idx] = replacement

        with open(file_path, "w", encoding="utf-8") as f:
            f.writelines(lines)

        print(f"[PATCHER] Applied fix to {fix['file_path']} line {line_number}", file=sys.stderr)
        return True

    except Exception as e:
        print(f"[PATCHER] Error applying fix to {file_path}: {e}", file=sys.stderr)
        return False


def apply_all_fixes(repo_path: str, fixes: List[Dict[str, Any]]) -> List[Tuple[Dict[str, Any], bool]]:
    """
    Apply all fixes and return list of (fix, success) tuples.
    Sorts fixes by file and reverse line number to avoid index shifting.
    """
    # Sort by file path, then by line number descending
    # This prevents line number shifts when deleting/adding lines
    sorted_fixes = sorted(
        fixes,
        key=lambda f: (f.get("file_path", ""), -f.get("line_number", 0))
    )

    results = []
    for fix in sorted_fixes:
        success = apply_fix_to_file(repo_path, fix)
        results.append((fix, success))
    
    return results
